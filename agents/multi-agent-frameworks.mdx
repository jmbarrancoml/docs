---
title: "Multi-agent frameworks"
description: "Comprehensive guide to multi-agent system architectures and coordination frameworks, including distributed problem solving, agent societies, emergent behavior, and scalable multi-agent platforms."
---

# Multi-agent frameworks

Multi-agent systems represent the evolution from single autonomous agents to societies of interacting intelligent entities. This comprehensive guide explores the architectures, frameworks, and design patterns that enable multiple agents to work together effectively, from simple coordination to complex emergent behaviors.

## Understanding multi-agent systems

### Foundational concepts and architectures

Multi-agent systems (MAS) consist of multiple interacting agents that collectively solve problems that are beyond the capabilities of individual agents:

```python
import numpy as np
from typing import Dict, List, Optional, Any, Callable, Tuple, Set, Union
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
from enum import Enum
import asyncio
import json
import time
import uuid
from collections import defaultdict, deque
import threading
import queue

class AgentRole(Enum):
    COORDINATOR = "coordinator"
    EXECUTOR = "executor"
    MONITOR = "monitor"
    FACILITATOR = "facilitator"
    SPECIALIST = "specialist"
    NEGOTIATOR = "negotiator"

class InteractionType(Enum):
    COOPERATION = "cooperation"
    COMPETITION = "competition"
    COORDINATION = "coordination"
    NEGOTIATION = "negotiation"
    COLLABORATION = "collaboration"

class SystemTopology(Enum):
    HIERARCHICAL = "hierarchical"
    FLAT = "flat"
    HYBRID = "hybrid"
    NETWORK = "network"
    FEDERATED = "federated"

@dataclass
class AgentCapability:
    """Represents an agent's capability"""
    name: str
    proficiency: float  # 0.0 to 1.0
    resource_cost: float
    availability: bool = True
    dependencies: List[str] = field(default_factory=list)

@dataclass
class Task:
    """Represents a task to be executed"""
    id: str
    description: str
    required_capabilities: List[str]
    priority: float = 1.0
    deadline: Optional[float] = None
    subtasks: List['Task'] = field(default_factory=list)
    dependencies: List[str] = field(default_factory=list)
    estimated_duration: float = 1.0
    status: str = "pending"  # pending, assigned, executing, completed, failed
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class Message:
    """Message structure for inter-agent communication"""
    id: str
    sender_id: str
    receiver_id: str
    message_type: str
    content: Any
    timestamp: float
    priority: int = 1
    requires_response: bool = False
    conversation_id: Optional[str] = None
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

class MultiAgentFramework(ABC):
    """Abstract base class for multi-agent frameworks"""
    
    def __init__(self, name: str):
        self.name = name
        self.agents = {}
        self.message_bus = None
        self.task_queue = queue.Queue()
        self.system_state = {}
        self.performance_metrics = {}
        
    @abstractmethod
    def add_agent(self, agent: 'Agent') -> None:
        """Add an agent to the framework"""
        pass
    
    @abstractmethod
    def remove_agent(self, agent_id: str) -> None:
        """Remove an agent from the framework"""
        pass
    
    @abstractmethod
    def assign_task(self, task: Task) -> bool:
        """Assign a task to appropriate agent(s)"""
        pass
    
    @abstractmethod
    def coordinate_agents(self) -> None:
        """Coordinate agent activities"""
        pass
    
    def get_system_status(self) -> Dict[str, Any]:
        """Get current system status"""
        return {
            'framework': self.name,
            'agent_count': len(self.agents),
            'active_agents': len([a for a in self.agents.values() if a.is_active()]),
            'pending_tasks': self.task_queue.qsize(),
            'system_state': self.system_state,
            'performance': self.performance_metrics
        }

class Agent(ABC):
    """Abstract base class for agents in multi-agent systems"""
    
    def __init__(self, agent_id: str, role: AgentRole = AgentRole.EXECUTOR):
        self.id = agent_id
        self.role = role
        self.capabilities = {}
        self.current_tasks = []
        self.message_queue = queue.Queue()
        self.knowledge_base = {}
        self.beliefs = {}
        self.goals = []
        self.active = True
        self.framework = None
        
    @abstractmethod
    def process_message(self, message: Message) -> Optional[Message]:
        """Process incoming message"""
        pass
    
    @abstractmethod
    def execute_task(self, task: Task) -> Dict[str, Any]:
        """Execute assigned task"""
        pass
    
    def add_capability(self, capability: AgentCapability):
        """Add a capability to the agent"""
        self.capabilities[capability.name] = capability
        
    def can_handle_task(self, task: Task) -> Tuple[bool, float]:
        """Check if agent can handle task and return confidence score"""
        required_caps = set(task.required_capabilities)
        available_caps = set(cap for cap, info in self.capabilities.items() 
                           if info.availability)
        
        if not required_caps.issubset(available_caps):
            return False, 0.0
        
        # Calculate confidence based on capability proficiency
        proficiency_scores = [
            self.capabilities[cap].proficiency 
            for cap in required_caps
        ]
        
        confidence = np.mean(proficiency_scores) if proficiency_scores else 0.0
        return True, confidence
    
    def send_message(self, message: Message):
        """Send message through framework"""
        if self.framework:
            self.framework.route_message(message)
    
    def receive_message(self, message: Message):
        """Receive message"""
        self.message_queue.put(message)
    
    def is_active(self) -> bool:
        """Check if agent is active"""
        return self.active
    
    def get_status(self) -> Dict[str, Any]:
        """Get agent status"""
        return {
            'id': self.id,
            'role': self.role.value,
            'active': self.active,
            'current_tasks': len(self.current_tasks),
            'capabilities': list(self.capabilities.keys()),
            'pending_messages': self.message_queue.qsize()
        }

class HierarchicalFramework(MultiAgentFramework):
    """Hierarchical multi-agent framework with coordinator-executor structure"""
    
    def __init__(self, name: str = "HierarchicalMAS"):
        super().__init__(name)
        self.coordinators = {}
        self.executors = {}
        self.task_assignments = {}
        self.hierarchy_levels = {}
        
    def add_agent(self, agent: Agent, level: int = 1) -> None:
        """Add agent with hierarchy level"""
        agent.framework = self
        self.agents[agent.id] = agent
        self.hierarchy_levels[agent.id] = level
        
        if agent.role == AgentRole.COORDINATOR:
            self.coordinators[agent.id] = agent
        else:
            self.executors[agent.id] = agent
    
    def remove_agent(self, agent_id: str) -> None:
        """Remove agent from framework"""
        if agent_id in self.agents:
            del self.agents[agent_id]
            if agent_id in self.coordinators:
                del self.coordinators[agent_id]
            if agent_id in self.executors:
                del self.executors[agent_id]
            if agent_id in self.hierarchy_levels:
                del self.hierarchy_levels[agent_id]
    
    def assign_task(self, task: Task) -> bool:
        """Assign task using hierarchical approach"""
        
        # Find best coordinator for task
        best_coordinator = self._select_coordinator(task)
        
        if best_coordinator:
            # Coordinator will handle task decomposition and assignment
            assignment_result = best_coordinator.coordinate_task(task)
            
            if assignment_result['success']:
                self.task_assignments[task.id] = {
                    'coordinator': best_coordinator.id,
                    'executors': assignment_result['assigned_agents'],
                    'assignment_time': time.time()
                }
                return True
        
        return False
    
    def coordinate_agents(self) -> None:
        """Coordinate agents in hierarchical structure"""
        
        # Update coordinator agents about system state
        system_info = self._gather_system_information()
        
        for coordinator_id, coordinator in self.coordinators.items():
            status_message = Message(
                id=str(uuid.uuid4()),
                sender_id="framework",
                receiver_id=coordinator_id,
                message_type="system_status",
                content=system_info,
                timestamp=time.time()
            )
            coordinator.receive_message(status_message)
        
        # Process coordination decisions
        self._process_coordination_decisions()
    
    def _select_coordinator(self, task: Task) -> Optional['CoordinatorAgent']:
        """Select best coordinator for task"""
        
        best_coordinator = None
        best_score = 0.0
        
        for coordinator in self.coordinators.values():
            if isinstance(coordinator, CoordinatorAgent):
                score = coordinator.evaluate_task_fit(task)
                if score > best_score:
                    best_score = score
                    best_coordinator = coordinator
        
        return best_coordinator
    
    def _gather_system_information(self) -> Dict[str, Any]:
        """Gather system-wide information"""
        
        return {
            'total_agents': len(self.agents),
            'active_executors': len([e for e in self.executors.values() if e.is_active()]),
            'pending_tasks': self.task_queue.qsize(),
            'system_load': self._calculate_system_load(),
            'resource_availability': self._assess_resource_availability()
        }
    
    def _calculate_system_load(self) -> float:
        """Calculate current system load"""
        
        total_capacity = 0
        current_load = 0
        
        for agent in self.executors.values():
            total_capacity += 1  # Simplified: each agent has capacity 1
            current_load += len(agent.current_tasks)
        
        return current_load / total_capacity if total_capacity > 0 else 0.0
    
    def _assess_resource_availability(self) -> Dict[str, float]:
        """Assess availability of different resources/capabilities"""
        
        capability_availability = defaultdict(list)
        
        for agent in self.executors.values():
            for cap_name, capability in agent.capabilities.items():
                if capability.availability:
                    capability_availability[cap_name].append(capability.proficiency)
        
        return {
            cap: np.mean(proficiencies) 
            for cap, proficiencies in capability_availability.items()
        }
    
    def _process_coordination_decisions(self):
        """Process coordination decisions from coordinator agents"""
        
        for coordinator in self.coordinators.values():
            if hasattr(coordinator, 'get_coordination_decisions'):
                decisions = coordinator.get_coordination_decisions()
                self._execute_coordination_decisions(decisions)
    
    def _execute_coordination_decisions(self, decisions: List[Dict]):
        """Execute coordination decisions"""
        
        for decision in decisions:
            if decision['type'] == 'reassign_task':
                self._reassign_task(decision['task_id'], decision['new_agent'])
            elif decision['type'] == 'replicate_agent':
                self._handle_agent_replication(decision)
            elif decision['type'] == 'load_balance':
                self._perform_load_balancing()
    
    def _reassign_task(self, task_id: str, new_agent_id: str):
        """Reassign task to different agent"""
        
        if task_id in self.task_assignments and new_agent_id in self.agents:
            assignment = self.task_assignments[task_id]
            assignment['executors'] = [new_agent_id]
            assignment['reassignment_time'] = time.time()
    
    def _handle_agent_replication(self, decision: Dict):
        """Handle agent replication for scaling"""
        
        # Mock implementation - would create new agent instance
        print(f"Would replicate agent {decision['agent_id']} for scaling")
    
    def _perform_load_balancing(self):
        """Perform load balancing across agents"""
        
        # Calculate current loads
        agent_loads = {
            agent_id: len(agent.current_tasks)
            for agent_id, agent in self.executors.items()
        }
        
        # Identify overloaded and underloaded agents
        avg_load = np.mean(list(agent_loads.values())) if agent_loads else 0
        
        overloaded = [aid for aid, load in agent_loads.items() if load > avg_load * 1.5]
        underloaded = [aid for aid, load in agent_loads.items() if load < avg_load * 0.5]
        
        # Mock rebalancing - would move tasks between agents
        if overloaded and underloaded:
            print(f"Load balancing: {len(overloaded)} overloaded, {len(underloaded)} underloaded agents")

class CoordinatorAgent(Agent):
    """Coordinator agent for hierarchical systems"""
    
    def __init__(self, agent_id: str):
        super().__init__(agent_id, AgentRole.COORDINATOR)
        self.managed_agents = {}
        self.coordination_decisions = []
        self.task_decomposition_strategies = {}
        
    def process_message(self, message: Message) -> Optional[Message]:
        """Process coordination messages"""
        
        if message.message_type == "system_status":
            self._update_system_knowledge(message.content)
            return None
        
        elif message.message_type == "task_request":
            return self._handle_task_request(message)
        
        elif message.message_type == "status_report":
            self._process_status_report(message)
            return None
        
        return None
    
    def execute_task(self, task: Task) -> Dict[str, Any]:
        """Coordinate task execution rather than executing directly"""
        
        result = self.coordinate_task(task)
        
        return {
            'success': result['success'],
            'coordination_result': result,
            'execution_time': result.get('coordination_time', 0.0)
        }
    
    def coordinate_task(self, task: Task) -> Dict[str, Any]:
        """Coordinate execution of a complex task"""
        
        coordination_start = time.time()
        
        # Decompose task if needed
        subtasks = self._decompose_task(task)
        
        # Assign subtasks to appropriate agents
        assignments = self._assign_subtasks(subtasks)
        
        # Monitor execution
        monitoring_plan = self._create_monitoring_plan(assignments)
        
        coordination_time = time.time() - coordination_start
        
        return {
            'success': len(assignments) > 0,
            'subtasks': subtasks,
            'assignments': assignments,
            'monitoring_plan': monitoring_plan,
            'coordination_time': coordination_time,
            'assigned_agents': [a['agent_id'] for a in assignments]
        }
    
    def evaluate_task_fit(self, task: Task) -> float:
        """Evaluate how well this coordinator can handle the task"""
        
        # Check if we have managed agents with required capabilities
        required_caps = set(task.required_capabilities)
        available_caps = set()
        
        for agent in self.managed_agents.values():
            available_caps.update(agent.capabilities.keys())
        
        capability_coverage = len(required_caps.intersection(available_caps)) / len(required_caps) if required_caps else 1.0
        
        # Consider coordinator's experience with similar tasks
        experience_factor = 0.8  # Mock experience factor
        
        # Consider current system load
        load_factor = max(0.1, 1.0 - self.framework._calculate_system_load()) if self.framework else 0.5
        
        return capability_coverage * experience_factor * load_factor
    
    def _decompose_task(self, task: Task) -> List[Task]:
        """Decompose complex task into subtasks"""
        
        if task.subtasks:
            return task.subtasks
        
        # Simple decomposition strategy based on capabilities
        subtasks = []
        
        for i, capability in enumerate(task.required_capabilities):
            subtask = Task(
                id=f"{task.id}_sub_{i}",
                description=f"Subtask requiring {capability}",
                required_capabilities=[capability],
                priority=task.priority,
                estimated_duration=task.estimated_duration / len(task.required_capabilities)
            )
            subtasks.append(subtask)
        
        return subtasks
    
    def _assign_subtasks(self, subtasks: List[Task]) -> List[Dict[str, Any]]:
        """Assign subtasks to managed agents"""
        
        assignments = []
        
        for subtask in subtasks:
            best_agent = self._select_best_agent(subtask)
            
            if best_agent:
                assignment = {
                    'task_id': subtask.id,
                    'agent_id': best_agent.id,
                    'assignment_time': time.time(),
                    'estimated_completion': time.time() + subtask.estimated_duration
                }
                assignments.append(assignment)
                
                # Send task to agent
                task_message = Message(
                    id=str(uuid.uuid4()),
                    sender_id=self.id,
                    receiver_id=best_agent.id,
                    message_type="task_assignment",
                    content=subtask,
                    timestamp=time.time(),
                    requires_response=True
                )
                best_agent.receive_message(task_message)
        
        return assignments
    
    def _select_best_agent(self, task: Task) -> Optional[Agent]:
        """Select best agent for a specific task"""
        
        best_agent = None
        best_score = 0.0
        
        for agent in self.managed_agents.values():
            can_handle, confidence = agent.can_handle_task(task)
            
            if can_handle:
                # Consider agent's current load
                load_penalty = len(agent.current_tasks) * 0.1
                score = confidence - load_penalty
                
                if score > best_score:
                    best_score = score
                    best_agent = agent
        
        return best_agent
    
    def _create_monitoring_plan(self, assignments: List[Dict]) -> Dict[str, Any]:
        """Create plan for monitoring task execution"""
        
        return {
            'checkpoints': [
                {
                    'time': time.time() + 60,  # Check in 1 minute
                    'type': 'progress_check',
                    'assignments': [a['task_id'] for a in assignments]
                }
            ],
            'escalation_triggers': [
                'task_overdue',
                'agent_unresponsive',
                'quality_threshold_not_met'
            ],
            'monitoring_frequency': 30  # seconds
        }
    
    def _update_system_knowledge(self, system_status: Dict[str, Any]):
        """Update knowledge about system state"""
        
        self.knowledge_base['system_status'] = system_status
        self.knowledge_base['last_update'] = time.time()
        
        # Make coordination decisions based on system state
        if system_status['system_load'] > 0.8:
            self.coordination_decisions.append({
                'type': 'load_balance',
                'reason': 'high_system_load',
                'timestamp': time.time()
            })
    
    def _handle_task_request(self, message: Message) -> Message:
        """Handle task assignment request"""
        
        task = message.content
        coordination_result = self.coordinate_task(task)
        
        response = Message(
            id=str(uuid.uuid4()),
            sender_id=self.id,
            receiver_id=message.sender_id,
            message_type="task_response",
            content=coordination_result,
            timestamp=time.time(),
            conversation_id=message.conversation_id
        )
        
        return response
    
    def _process_status_report(self, message: Message):
        """Process status report from managed agent"""
        
        status = message.content
        self.knowledge_base[f"agent_{message.sender_id}_status"] = status
        
        # Check for issues that need coordination response
        if status.get('task_failed') or status.get('help_needed'):
            self.coordination_decisions.append({
                'type': 'assistance_needed',
                'agent_id': message.sender_id,
                'issue': status,
                'timestamp': time.time()
            })
    
    def get_coordination_decisions(self) -> List[Dict]:
        """Get pending coordination decisions"""
        
        decisions = self.coordination_decisions.copy()
        self.coordination_decisions.clear()
        return decisions

class ExecutorAgent(Agent):
    """Executor agent for task execution"""
    
    def __init__(self, agent_id: str, specialization: str = "general"):
        super().__init__(agent_id, AgentRole.EXECUTOR)
        self.specialization = specialization
        self.execution_history = []
        self.performance_metrics = {
            'tasks_completed': 0,
            'success_rate': 1.0,
            'avg_execution_time': 0.0
        }
        
    def process_message(self, message: Message) -> Optional[Message]:
        """Process executor messages"""
        
        if message.message_type == "task_assignment":
            return self._handle_task_assignment(message)
        
        elif message.message_type == "status_query":
            return self._handle_status_query(message)
        
        elif message.message_type == "collaboration_request":
            return self._handle_collaboration_request(message)
        
        return None
    
    def execute_task(self, task: Task) -> Dict[str, Any]:
        """Execute assigned task"""
        
        execution_start = time.time()
        
        # Check if task can be handled
        can_handle, confidence = self.can_handle_task(task)
        
        if not can_handle:
            return {
                'success': False,
                'reason': 'insufficient_capabilities',
                'required_capabilities': task.required_capabilities,
                'available_capabilities': list(self.capabilities.keys())
            }
        
        # Simulate task execution
        result = self._perform_task_execution(task, confidence)
        
        execution_time = time.time() - execution_start
        
        # Update performance metrics
        self._update_performance_metrics(result['success'], execution_time)
        
        # Record in execution history
        self.execution_history.append({
            'task_id': task.id,
            'success': result['success'],
            'execution_time': execution_time,
            'timestamp': time.time()
        })
        
        result['execution_time'] = execution_time
        return result
    
    def _handle_task_assignment(self, message: Message) -> Message:
        """Handle task assignment from coordinator"""
        
        task = message.content
        self.current_tasks.append(task)
        
        # Execute task
        execution_result = self.execute_task(task)
        
        # Remove from current tasks
        self.current_tasks = [t for t in self.current_tasks if t.id != task.id]
        
        # Send response back to coordinator
        response = Message(
            id=str(uuid.uuid4()),
            sender_id=self.id,
            receiver_id=message.sender_id,
            message_type="task_completion",
            content=execution_result,
            timestamp=time.time(),
            conversation_id=message.conversation_id
        )
        
        return response
    
    def _handle_status_query(self, message: Message) -> Message:
        """Handle status query"""
        
        status = self.get_status()
        status['performance_metrics'] = self.performance_metrics
        
        response = Message(
            id=str(uuid.uuid4()),
            sender_id=self.id,
            receiver_id=message.sender_id,
            message_type="status_response",
            content=status,
            timestamp=time.time()
        )
        
        return response
    
    def _handle_collaboration_request(self, message: Message) -> Message:
        """Handle collaboration request from other agent"""
        
        collaboration_request = message.content
        
        # Evaluate if we can collaborate
        can_collaborate = self._evaluate_collaboration_potential(collaboration_request)
        
        response_content = {
            'can_collaborate': can_collaborate,
            'available_capabilities': list(self.capabilities.keys()),
            'current_load': len(self.current_tasks)
        }
        
        response = Message(
            id=str(uuid.uuid4()),
            sender_id=self.id,
            receiver_id=message.sender_id,
            message_type="collaboration_response",
            content=response_content,
            timestamp=time.time()
        )
        
        return response
    
    def _perform_task_execution(self, task: Task, confidence: float) -> Dict[str, Any]:
        """Perform actual task execution (mock implementation)"""
        
        # Simulate execution based on confidence and task complexity
        execution_success_probability = confidence * 0.9  # Base success rate
        
        # Adjust for task complexity
        complexity_factor = min(1.0, len(task.required_capabilities) / 3.0)
        execution_success_probability *= (1.0 - complexity_factor * 0.2)
        
        # Random execution
        success = np.random.random() < execution_success_probability
        
        if success:
            return {
                'success': True,
                'result': f"Task {task.id} completed successfully",
                'confidence': confidence,
                'quality_score': confidence * np.random.uniform(0.8, 1.0)
            }
        else:
            return {
                'success': False,
                'reason': 'execution_failed',
                'attempted_approach': f"Used {task.required_capabilities} capabilities",
                'failure_analysis': 'Insufficient proficiency or resource constraints'
            }
    
    def _evaluate_collaboration_potential(self, collaboration_request: Dict) -> bool:
        """Evaluate potential for collaboration"""
        
        required_capabilities = collaboration_request.get('required_capabilities', [])
        
        # Check capability overlap
        our_capabilities = set(self.capabilities.keys())
        needed_capabilities = set(required_capabilities)
        
        overlap = our_capabilities.intersection(needed_capabilities)
        
        # Can collaborate if we have at least one needed capability and aren't overloaded
        return len(overlap) > 0 and len(self.current_tasks) < 3
    
    def _update_performance_metrics(self, success: bool, execution_time: float):
        """Update agent performance metrics"""
        
        # Update task count
        self.performance_metrics['tasks_completed'] += 1
        
        # Update success rate (exponential moving average)
        current_rate = self.performance_metrics['success_rate']
        alpha = 0.1  # Learning rate
        self.performance_metrics['success_rate'] = (
            alpha * (1.0 if success else 0.0) + (1 - alpha) * current_rate
        )
        
        # Update average execution time
        current_avg = self.performance_metrics['avg_execution_time']
        task_count = self.performance_metrics['tasks_completed']
        self.performance_metrics['avg_execution_time'] = (
            (current_avg * (task_count - 1) + execution_time) / task_count
        )

class FederatedFramework(MultiAgentFramework):
    """Federated multi-agent framework for distributed autonomous systems"""
    
    def __init__(self, name: str = "FederatedMAS"):
        super().__init__(name)
        self.federations = {}  # Groups of agents
        self.inter_federation_protocols = {}
        self.consensus_mechanisms = {}
        self.reputation_system = {}
        
    def add_agent(self, agent: Agent, federation_id: str = "default") -> None:
        """Add agent to specific federation"""
        
        agent.framework = self
        self.agents[agent.id] = agent
        
        if federation_id not in self.federations:
            self.federations[federation_id] = {
                'agents': {},
                'coordinator': None,
                'policies': {},
                'resources': {}
            }
        
        self.federations[federation_id]['agents'][agent.id] = agent
        
        # Initialize reputation
        self.reputation_system[agent.id] = {
            'trust_score': 0.5,
            'reliability_score': 0.5,
            'collaboration_score': 0.5
        }
    
    def remove_agent(self, agent_id: str) -> None:
        """Remove agent from federation"""
        
        if agent_id in self.agents:
            # Find which federation the agent belongs to
            for federation_id, federation in self.federations.items():
                if agent_id in federation['agents']:
                    del federation['agents'][agent_id]
                    break
            
            del self.agents[agent_id]
            if agent_id in self.reputation_system:
                del self.reputation_system[agent_id]
    
    def assign_task(self, task: Task, federation_id: Optional[str] = None) -> bool:
        """Assign task using federated approach"""
        
        if federation_id and federation_id in self.federations:
            # Assign within specific federation
            return self._assign_within_federation(task, federation_id)
        else:
            # Find best federation for task
            best_federation = self._select_best_federation(task)
            
            if best_federation:
                return self._assign_within_federation(task, best_federation)
        
        return False
    
    def coordinate_agents(self) -> None:
        """Coordinate agents using federated approach"""
        
        # Intra-federation coordination
        for federation_id in self.federations:
            self._coordinate_federation(federation_id)
        
        # Inter-federation coordination
        self._coordinate_between_federations()
        
        # Update reputation scores
        self._update_reputation_scores()
    
    def create_federation(self, federation_id: str, policies: Dict[str, Any]) -> bool:
        """Create new federation with specific policies"""
        
        if federation_id not in self.federations:
            self.federations[federation_id] = {
                'agents': {},
                'coordinator': None,
                'policies': policies,
                'resources': {},
                'creation_time': time.time()
            }
            return True
        
        return False
    
    def _assign_within_federation(self, task: Task, federation_id: str) -> bool:
        """Assign task within specific federation"""
        
        federation = self.federations[federation_id]
        available_agents = [
            agent for agent in federation['agents'].values()
            if agent.is_active()
        ]
        
        if not available_agents:
            return False
        
        # Use auction-based assignment
        auction_result = self._conduct_task_auction(task, available_agents)
        
        if auction_result['winner']:
            # Assign task to winning agent
            winner = auction_result['winner']
            assignment_message = Message(
                id=str(uuid.uuid4()),
                sender_id="federation_coordinator",
                receiver_id=winner.id,
                message_type="task_assignment",
                content=task,
                timestamp=time.time()
            )
            
            winner.receive_message(assignment_message)
            return True
        
        return False
    
    def _select_best_federation(self, task: Task) -> Optional[str]:
        """Select best federation for task"""
        
        best_federation = None
        best_score = 0.0
        
        for federation_id, federation in self.federations.items():
            score = self._evaluate_federation_fit(task, federation)
            
            if score > best_score:
                best_score = score
                best_federation = federation_id
        
        return best_federation if best_score > 0.3 else None
    
    def _evaluate_federation_fit(self, task: Task, federation: Dict) -> float:
        """Evaluate how well a federation can handle the task"""
        
        agents = federation['agents'].values()
        
        if not agents:
            return 0.0
        
        # Check capability coverage
        required_caps = set(task.required_capabilities)
        available_caps = set()
        
        for agent in agents:
            available_caps.update(agent.capabilities.keys())
        
        capability_score = len(required_caps.intersection(available_caps)) / len(required_caps) if required_caps else 1.0
        
        # Check agent availability and quality
        active_agents = [agent for agent in agents if agent.is_active()]
        availability_score = len(active_agents) / max(1, len(agents))
        
        # Check federation reputation
        reputation_scores = [
            self.reputation_system.get(agent.id, {}).get('trust_score', 0.5)
            for agent in agents
        ]
        reputation_score = np.mean(reputation_scores) if reputation_scores else 0.5
        
        return capability_score * availability_score * reputation_score
    
    def _conduct_task_auction(self, task: Task, agents: List[Agent]) -> Dict[str, Any]:
        """Conduct auction for task assignment"""
        
        bids = []
        
        for agent in agents:
            can_handle, confidence = agent.can_handle_task(task)
            
            if can_handle:
                # Calculate bid based on confidence and current load
                load_factor = max(0.1, 1.0 - len(agent.current_tasks) * 0.2)
                reputation = self.reputation_system.get(agent.id, {}).get('trust_score', 0.5)
                
                bid_value = confidence * load_factor * reputation
                
                bids.append({
                    'agent': agent,
                    'bid_value': bid_value,
                    'confidence': confidence,
                    'estimated_cost': 1.0 / confidence  # Higher confidence = lower cost
                })
        
        if bids:
            # Select winner (highest bid value)
            winner_bid = max(bids, key=lambda b: b['bid_value'])
            
            return {
                'winner': winner_bid['agent'],
                'winning_bid': winner_bid['bid_value'],
                'all_bids': bids
            }
        
        return {'winner': None, 'winning_bid': 0.0, 'all_bids': []}
    
    def _coordinate_federation(self, federation_id: str):
        """Coordinate agents within a federation"""
        
        federation = self.federations[federation_id]
        agents = list(federation['agents'].values())
        
        if not agents:
            return
        
        # Gather federation status
        federation_status = self._gather_federation_status(agents)
        
        # Make coordination decisions
        coordination_actions = self._plan_federation_coordination(federation_status)
        
        # Execute coordination actions
        for action in coordination_actions:
            self._execute_coordination_action(action, federation_id)
    
    def _coordinate_between_federations(self):
        """Coordinate between different federations"""
        
        # Find cross-federation collaboration opportunities
        collaboration_opportunities = self._identify_collaboration_opportunities()
        
        # Negotiate resource sharing
        sharing_agreements = self._negotiate_resource_sharing()
        
        # Update inter-federation protocols
        self._update_inter_federation_protocols(collaboration_opportunities, sharing_agreements)
    
    def _update_reputation_scores(self):
        """Update reputation scores based on recent performance"""
        
        for agent_id, agent in self.agents.items():
            if hasattr(agent, 'performance_metrics'):
                metrics = agent.performance_metrics
                
                # Update trust score based on success rate
                success_rate = metrics.get('success_rate', 0.5)
                self.reputation_system[agent_id]['trust_score'] = success_rate
                
                # Update reliability based on task completion ratio
                tasks_completed = metrics.get('tasks_completed', 0)
                reliability = min(1.0, tasks_completed / max(1, tasks_completed + len(agent.current_tasks)))
                self.reputation_system[agent_id]['reliability_score'] = reliability
                
                # Collaboration score could be updated based on inter-agent interactions
                # For now, maintain current score with slight decay
                current_collab = self.reputation_system[agent_id]['collaboration_score']
                self.reputation_system[agent_id]['collaboration_score'] = current_collab * 0.95 + 0.05 * 0.5
    
    def _gather_federation_status(self, agents: List[Agent]) -> Dict[str, Any]:
        """Gather status information from federation agents"""
        
        return {
            'agent_count': len(agents),
            'active_agents': len([a for a in agents if a.is_active()]),
            'total_tasks': sum(len(a.current_tasks) for a in agents),
            'avg_performance': np.mean([
                self.reputation_system.get(a.id, {}).get('trust_score', 0.5)
                for a in agents
            ])
        }
    
    def _plan_federation_coordination(self, status: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Plan coordination actions for federation"""
        
        actions = []
        
        # If performance is low, plan improvement actions
        if status['avg_performance'] < 0.6:
            actions.append({
                'type': 'performance_improvement',
                'target': 'federation',
                'measures': ['agent_training', 'task_redistribution']
            })
        
        # If load is high, plan load balancing
        avg_tasks_per_agent = status['total_tasks'] / max(1, status['active_agents'])
        if avg_tasks_per_agent > 2:
            actions.append({
                'type': 'load_balancing',
                'target': 'federation',
                'measures': ['task_redistribution', 'agent_scaling']
            })
        
        return actions
    
    def _execute_coordination_action(self, action: Dict[str, Any], federation_id: str):
        """Execute coordination action within federation"""
        
        if action['type'] == 'performance_improvement':
            self._improve_federation_performance(federation_id)
        elif action['type'] == 'load_balancing':
            self._balance_federation_load(federation_id)
    
    def _improve_federation_performance(self, federation_id: str):
        """Improve performance of federation agents"""
        
        federation = self.federations[federation_id]
        
        # Identify low-performing agents
        low_performers = [
            agent for agent in federation['agents'].values()
            if self.reputation_system.get(agent.id, {}).get('trust_score', 1.0) < 0.5
        ]
        
        # Send performance improvement messages
        for agent in low_performers:
            improvement_message = Message(
                id=str(uuid.uuid4()),
                sender_id="federation_coordinator",
                receiver_id=agent.id,
                message_type="performance_feedback",
                content={
                    'current_score': self.reputation_system[agent.id]['trust_score'],
                    'improvement_suggestions': ['capability_enhancement', 'collaboration_improvement']
                },
                timestamp=time.time()
            )
            agent.receive_message(improvement_message)
    
    def _balance_federation_load(self, federation_id: str):
        """Balance load within federation"""
        
        federation = self.federations[federation_id]
        agents = list(federation['agents'].values())
        
        # Calculate current loads
        loads = [(agent, len(agent.current_tasks)) for agent in agents]
        loads.sort(key=lambda x: x[1], reverse=True)
        
        # Move tasks from overloaded to underloaded agents
        if len(loads) >= 2:
            overloaded = loads[0]
            underloaded = loads[-1]
            
            if overloaded[1] > underloaded[1] + 1:
                # Mock task redistribution
                print(f"Would redistribute tasks from {overloaded[0].id} to {underloaded[0].id}")
    
    def _identify_collaboration_opportunities(self) -> List[Dict[str, Any]]:
        """Identify opportunities for cross-federation collaboration"""
        
        opportunities = []
        
        federation_ids = list(self.federations.keys())
        
        for i in range(len(federation_ids)):
            for j in range(i + 1, len(federation_ids)):
                fed_a = federation_ids[i]
                fed_b = federation_ids[j]
                
                # Analyze complementary capabilities
                caps_a = self._get_federation_capabilities(fed_a)
                caps_b = self._get_federation_capabilities(fed_b)
                
                complementary = caps_a.symmetric_difference(caps_b)
                
                if len(complementary) > 0:
                    opportunities.append({
                        'federations': [fed_a, fed_b],
                        'complementary_capabilities': list(complementary),
                        'collaboration_potential': len(complementary) / (len(caps_a) + len(caps_b))
                    })
        
        return opportunities
    
    def _get_federation_capabilities(self, federation_id: str) -> Set[str]:
        """Get all capabilities available in a federation"""
        
        capabilities = set()
        
        if federation_id in self.federations:
            for agent in self.federations[federation_id]['agents'].values():
                capabilities.update(agent.capabilities.keys())
        
        return capabilities
    
    def _negotiate_resource_sharing(self) -> List[Dict[str, Any]]:
        """Negotiate resource sharing agreements between federations"""
        
        agreements = []
        
        # Mock negotiation - in practice would use negotiation protocols
        for fed_id, federation in self.federations.items():
            if len(federation['agents']) > 2:  # Only federations with multiple agents
                agreements.append({
                    'provider': fed_id,
                    'resource_type': 'computational_capacity',
                    'availability': 0.3,  # 30% of capacity available for sharing
                    'cost': 1.0
                })
        
        return agreements
    
    def _update_inter_federation_protocols(self, opportunities: List[Dict], agreements: List[Dict]):
        """Update protocols for inter-federation coordination"""
        
        self.inter_federation_protocols.update({
            'collaboration_opportunities': opportunities,
            'resource_sharing_agreements': agreements,
            'last_update': time.time()
        })

# Integration with EderSpark for scientific multi-agent systems
class ScientificMultiAgentSystem(FederatedFramework):
    """Multi-agent system specialized for scientific research using EderSpark"""
    
    def __init__(self, api_key: str = ""):
        super().__init__("ScientificMAS")
        self.api_key = api_key
        self.research_domains = {}
        self.knowledge_graph = {}
        self.collaborative_projects = {}
        
        # Initialize specialized scientific federations
        self._initialize_scientific_federations()
        
    def _initialize_scientific_federations(self):
        """Initialize federations for different scientific domains"""
        
        scientific_domains = [
            "molecular_biology",
            "computational_chemistry", 
            "machine_learning",
            "materials_science",
            "drug_discovery"
        ]
        
        for domain in scientific_domains:
            policies = {
                'collaboration_openness': 0.8,
                'knowledge_sharing': 0.9,
                'resource_sharing': 0.7,
                'peer_review_required': True
            }
            
            self.create_federation(domain, policies)
            self.research_domains[domain] = {
                'active_projects': [],
                'expertise_level': 0.7,
                'collaboration_networks': []
            }
    
    def add_research_agent(self, agent: Agent, domain: str, 
                          expertise_areas: List[str]) -> None:
        """Add specialized research agent"""
        
        # Add domain-specific capabilities
        for area in expertise_areas:
            capability = AgentCapability(
                name=f"{domain}_{area}",
                proficiency=np.random.uniform(0.6, 0.95),
                resource_cost=1.0
            )
            agent.add_capability(capability)
        
        # Add to appropriate federation
        self.add_agent(agent, domain)
        
        # Update research domain information
        if domain in self.research_domains:
            self.research_domains[domain]['expertise_level'] = min(1.0, 
                self.research_domains[domain]['expertise_level'] + 0.1
            )
    
    def create_research_project(self, project_id: str, 
                              research_question: str,
                              required_domains: List[str],
                              timeline_weeks: int = 12) -> Dict[str, Any]:
        """Create collaborative research project"""
        
        project = {
            'id': project_id,
            'research_question': research_question,
            'required_domains': required_domains,
            'timeline_weeks': timeline_weeks,
            'participating_agents': [],
            'knowledge_contributions': [],
            'current_phase': 'planning',
            'creation_time': time.time()
        }
        
        # Find suitable agents from required domains
        suitable_agents = self._find_research_agents(required_domains)
        
        if len(suitable_agents) >= len(required_domains):
            # Form research team
            research_team = self._form_research_team(suitable_agents, project)
            project['participating_agents'] = research_team
            
            # Initialize collaborative workspace
            workspace = self._create_collaborative_workspace(project)
            project['workspace'] = workspace
            
            self.collaborative_projects[project_id] = project
            
            return {
                'success': True,
                'project': project,
                'team_size': len(research_team)
            }
        
        return {
            'success': False,
            'reason': 'insufficient_expertise',
            'required_domains': required_domains,
            'available_domains': list(self.federations.keys())
        }
    
    def _find_research_agents(self, required_domains: List[str]) -> List[Agent]:
        """Find agents suitable for research domains"""
        
        suitable_agents = []
        
        for domain in required_domains:
            if domain in self.federations:
                domain_agents = list(self.federations[domain]['agents'].values())
                
                # Select best agent from domain
                if domain_agents:
                    best_agent = max(domain_agents, 
                                   key=lambda a: self.reputation_system.get(a.id, {}).get('trust_score', 0.5))
                    suitable_agents.append(best_agent)
        
        return suitable_agents
    
    def _form_research_team(self, agents: List[Agent], project: Dict) -> List[str]:
        """Form research team and assign roles"""
        
        team = []
        
        # Assign roles based on agent capabilities and reputation
        sorted_agents = sorted(agents, 
                             key=lambda a: self.reputation_system.get(a.id, {}).get('trust_score', 0.5),
                             reverse=True)
        
        for i, agent in enumerate(sorted_agents):
            role = "lead_researcher" if i == 0 else f"researcher_{i}"
            
            team_assignment = {
                'agent_id': agent.id,
                'role': role,
                'responsibilities': self._define_research_responsibilities(role, project),
                'expertise_areas': list(agent.capabilities.keys())
            }
            
            team.append(agent.id)
            
            # Notify agent of team assignment
            assignment_message = Message(
                id=str(uuid.uuid4()),
                sender_id="research_coordinator",
                receiver_id=agent.id,
                message_type="research_assignment",
                content={
                    'project': project,
                    'team_assignment': team_assignment
                },
                timestamp=time.time()
            )
            
            agent.receive_message(assignment_message)
        
        return team
    
    def _create_collaborative_workspace(self, project: Dict) -> Dict[str, Any]:
        """Create collaborative workspace for research project"""
        
        return {
            'shared_knowledge_base': {},
            'literature_repository': [],
            'experiment_protocols': [],
            'data_sharing_agreements': [],
            'communication_channels': {
                'project_updates': [],
                'research_discussions': [],
                'peer_review_feedback': []
            },
            'version_control': {
                'documents': {},
                'code_repositories': {},
                'data_versions': {}
            }
        }
    
    def _define_research_responsibilities(self, role: str, project: Dict) -> List[str]:
        """Define responsibilities for research role"""
        
        if role == "lead_researcher":
            return [
                "project_coordination",
                "literature_review_oversight", 
                "methodology_design",
                "result_synthesis",
                "publication_preparation"
            ]
        else:
            return [
                "specialized_analysis",
                "data_collection",
                "experiment_execution",
                "literature_contribution",
                "peer_review_participation"
            ]
    
    def monitor_research_progress(self, project_id: str) -> Dict[str, Any]:
        """Monitor progress of collaborative research project"""
        
        if project_id not in self.collaborative_projects:
            return {'error': 'Project not found'}
        
        project = self.collaborative_projects[project_id]
        
        # Gather progress from participating agents
        progress_reports = self._gather_progress_reports(project)
        
        # Analyze collaboration effectiveness
        collaboration_metrics = self._analyze_collaboration_effectiveness(project)
        
        # Check milestone completion
        milestone_status = self._check_milestone_completion(project)
        
        return {
            'project_id': project_id,
            'current_phase': project['current_phase'],
            'progress_reports': progress_reports,
            'collaboration_metrics': collaboration_metrics,
            'milestone_status': milestone_status,
            'estimated_completion': self._estimate_project_completion(project)
        }
    
    def _gather_progress_reports(self, project: Dict) -> List[Dict]:
        """Gather progress reports from research team"""
        
        reports = []
        
        for agent_id in project['participating_agents']:
            if agent_id in self.agents:
                agent = self.agents[agent_id]
                
                # Request progress report
                report_request = Message(
                    id=str(uuid.uuid4()),
                    sender_id="research_monitor",
                    receiver_id=agent_id,
                    message_type="progress_report_request",
                    content={'project_id': project['id']},
                    timestamp=time.time(),
                    requires_response=True
                )
                
                agent.receive_message(report_request)
                
                # Mock progress report
                reports.append({
                    'agent_id': agent_id,
                    'completion_percentage': np.random.uniform(0.3, 0.9),
                    'current_activities': ['literature_analysis', 'data_processing'],
                    'challenges': ['data_quality_issues'] if np.random.random() > 0.7 else [],
                    'next_steps': ['result_validation', 'manuscript_preparation']
                })
        
        return reports
    
    def _analyze_collaboration_effectiveness(self, project: Dict) -> Dict[str, float]:
        """Analyze effectiveness of research collaboration"""
        
        team_agents = [self.agents[aid] for aid in project['participating_agents'] 
                      if aid in self.agents]
        
        # Communication frequency
        communication_score = 0.8  # Mock - would analyze actual message frequency
        
        # Knowledge sharing effectiveness
        knowledge_sharing_score = 0.7  # Mock - would analyze knowledge contributions
        
        # Task coordination efficiency
        coordination_score = np.mean([
            self.reputation_system.get(agent.id, {}).get('collaboration_score', 0.5)
            for agent in team_agents
        ])
        
        return {
            'communication_effectiveness': communication_score,
            'knowledge_sharing': knowledge_sharing_score,
            'coordination_efficiency': coordination_score,
            'overall_collaboration_score': np.mean([
                communication_score, knowledge_sharing_score, coordination_score
            ])
        }
    
    def _check_milestone_completion(self, project: Dict) -> Dict[str, Any]:
        """Check completion status of project milestones"""
        
        # Define standard research milestones
        milestones = [
            {'name': 'literature_review', 'expected_week': 2, 'weight': 0.2},
            {'name': 'methodology_design', 'expected_week': 4, 'weight': 0.2},
            {'name': 'data_collection', 'expected_week': 8, 'weight': 0.3},
            {'name': 'analysis_completion', 'expected_week': 10, 'weight': 0.2},
            {'name': 'manuscript_draft', 'expected_week': 12, 'weight': 0.1}
        ]
        
        current_week = (time.time() - project['creation_time']) / (7 * 24 * 3600)
        
        milestone_status = []
        
        for milestone in milestones:
            if current_week >= milestone['expected_week']:
                # Check if milestone should be completed
                completion_probability = min(1.0, current_week / milestone['expected_week'])
                completed = np.random.random() < completion_probability
            else:
                completed = False
            
            milestone_status.append({
                'name': milestone['name'],
                'completed': completed,
                'expected_week': milestone['expected_week'],
                'current_week': current_week,
                'on_schedule': current_week <= milestone['expected_week'] or completed
            })
        
        return {
            'milestones': milestone_status,
            'overall_progress': sum(m['weight'] for m in milestones 
                                  if milestone_status[milestones.index(m)]['completed']),
            'on_schedule': all(m['on_schedule'] for m in milestone_status)
        }
    
    def _estimate_project_completion(self, project: Dict) -> Dict[str, Any]:
        """Estimate project completion timeline"""
        
        planned_weeks = project['timeline_weeks']
        current_week = (time.time() - project['creation_time']) / (7 * 24 * 3600)
        
        # Get progress from milestone completion
        milestone_status = self._check_milestone_completion(project)
        overall_progress = milestone_status['overall_progress']
        
        if overall_progress > 0:
            estimated_total_weeks = current_week / overall_progress
            estimated_completion_date = project['creation_time'] + (estimated_total_weeks * 7 * 24 * 3600)
        else:
            estimated_total_weeks = planned_weeks
            estimated_completion_date = project['creation_time'] + (planned_weeks * 7 * 24 * 3600)
        
        return {
            'planned_weeks': planned_weeks,
            'current_week': current_week,
            'estimated_total_weeks': estimated_total_weeks,
            'estimated_completion_date': estimated_completion_date,
            'schedule_variance': estimated_total_weeks - planned_weeks,
            'on_track': abs(estimated_total_weeks - planned_weeks) <= 2  # Within 2 weeks
        }

def main():
    """Example usage of multi-agent frameworks"""
    
    print("Multi-Agent Framework Demo")
    print("=" * 50)
    
    # Test Hierarchical Framework
    print("\n1. Hierarchical Framework")
    hierarchical_mas = HierarchicalFramework("ResearchMAS")
    
    # Create coordinator agent
    coordinator = CoordinatorAgent("coordinator_1")
    hierarchical_mas.add_agent(coordinator, level=1)
    
    # Create executor agents
    for i in range(3):
        executor = ExecutorAgent(f"executor_{i}", f"specialization_{i}")
        
        # Add capabilities
        capabilities = ["data_analysis", "literature_review", "experiment_design"]
        for cap_name in capabilities[:i+1]:  # Each agent gets different number of capabilities
            capability = AgentCapability(
                name=cap_name,
                proficiency=np.random.uniform(0.7, 0.95),
                resource_cost=1.0
            )
            executor.add_capability(capability)
        
        hierarchical_mas.add_agent(executor, level=2)
        coordinator.managed_agents[executor.id] = executor
    
    # Create and assign task
    research_task = Task(
        id="research_task_1",
        description="Conduct comprehensive literature review on AI in drug discovery",
        required_capabilities=["literature_review", "data_analysis"],
        priority=0.8,
        estimated_duration=5.0
    )
    
    assignment_success = hierarchical_mas.assign_task(research_task)
    print(f"Task assignment success: {assignment_success}")
    
    # Coordinate agents
    hierarchical_mas.coordinate_agents()
    system_status = hierarchical_mas.get_system_status()
    print(f"System status: {system_status['active_agents']} active agents")
    
    # Test Federated Framework
    print("\n2. Federated Framework") 
    federated_mas = FederatedFramework("FederatedResearch")
    
    # Create federations for different research domains
    federated_mas.create_federation("biology", {
        'collaboration_openness': 0.9,
        'knowledge_sharing': 0.8
    })
    
    federated_mas.create_federation("chemistry", {
        'collaboration_openness': 0.7,
        'knowledge_sharing': 0.9
    })
    
    # Add agents to federations
    for i in range(4):
        agent = ExecutorAgent(f"fed_agent_{i}")
        
        # Add domain-specific capabilities
        if i < 2:
            # Biology agents
            bio_caps = ["protein_analysis", "genomics", "molecular_biology"]
            for cap in bio_caps:
                agent.add_capability(AgentCapability(cap, np.random.uniform(0.6, 0.9), 1.0))
            federated_mas.add_agent(agent, "biology")
        else:
            # Chemistry agents  
            chem_caps = ["chemical_synthesis", "spectroscopy", "computational_chemistry"]
            for cap in chem_caps:
                agent.add_capability(AgentCapability(cap, np.random.uniform(0.6, 0.9), 1.0))
            federated_mas.add_agent(agent, "chemistry")
    
    # Test cross-federation task
    interdisciplinary_task = Task(
        id="interdisciplinary_task",
        description="Design novel drug compounds using AI-guided molecular design",
        required_capabilities=["protein_analysis", "chemical_synthesis"],
        priority=0.9
    )
    
    fed_assignment = federated_mas.assign_task(interdisciplinary_task)
    print(f"Federated task assignment success: {fed_assignment}")
    
    federated_mas.coordinate_agents()
    
    # Test Scientific Multi-Agent System
    print("\n3. Scientific Multi-Agent System")
    scientific_mas = ScientificMultiAgentSystem("mock_api_key")
    
    # Add research agents
    research_domains = ["molecular_biology", "computational_chemistry", "machine_learning"]
    for i, domain in enumerate(research_domains):
        agent = ExecutorAgent(f"research_agent_{domain}")
        
        expertise_areas = {
            "molecular_biology": ["protein_folding", "gene_expression", "cell_signaling"],
            "computational_chemistry": ["molecular_dynamics", "quantum_chemistry", "drug_design"], 
            "machine_learning": ["neural_networks", "optimization", "pattern_recognition"]
        }
        
        scientific_mas.add_research_agent(agent, domain, expertise_areas[domain])
    
    # Create collaborative research project
    project_result = scientific_mas.create_research_project(
        "ai_drug_discovery_2024",
        "How can machine learning improve drug discovery for neurodegenerative diseases?",
        ["molecular_biology", "computational_chemistry", "machine_learning"],
        timeline_weeks=16
    )
    
    if project_result['success']:
        print(f"Research project created with team of {project_result['team_size']} agents")
        
        # Monitor progress
        progress = scientific_mas.monitor_research_progress("ai_drug_discovery_2024")
        print(f"Project progress: {progress['milestone_status']['overall_progress']:.2f}")
        
        collaboration_score = progress['collaboration_metrics']['overall_collaboration_score']
        print(f"Collaboration effectiveness: {collaboration_score:.2f}")
    
    return hierarchical_mas, federated_mas, scientific_mas

if __name__ == "__main__":
    hierarchical_mas, federated_mas, scientific_mas = main()
```

This comprehensive guide to multi-agent frameworks provides the architectural foundations and practical implementations needed to build sophisticated distributed AI systems. From hierarchical coordination structures to federated autonomous systems, these frameworks enable multiple agents to collaborate effectively on complex problems that exceed individual agent capabilities.

The integration with EderSpark's scientific research context demonstrates how multi-agent systems can be specialized for collaborative research, enabling teams of AI agents to work together on interdisciplinary scientific projects with proper coordination, knowledge sharing, and progress monitoring.